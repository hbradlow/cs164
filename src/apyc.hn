/* -*- mode: fundamental; c-file-style: "stroustrup"; indent-tabs-mode: nil -*- */
/*
Responsibilities:

Henry:
Types
Datastructures
Static typing
arithmetic

Kevin:
Function defs
class
indentation
ID

Will:
If/while/- control

*/

/* apyc: Bison Parser */

/* Authors: YOUR NAMES HERE */

%define semantic_tree_type "AST"

%token INT
%token ID

%{
  #include <string>
  #include "apyc.h"
  #include "ast.h"
  #include <cstdio>
  #include <cstdlib>
  #include <string>

  using namespace std;

  static AST_Ptr theTree;

%}

%debug
%define error_function error

/* A token declaration such as
 *   %token INDENT
 * declares a new integer constant INDENT, which serves as a syntactic category
 * (suitable for output by the lexer) identifying a kind of token, which we
 * also often refer to as INDENT. A declaration such as
 *   %token IF "if"
 * defines a constant IF and makes it the syntactic category for the token
 * "if".  The built-in function yyexternal_token_name(...) maps between 
 * syntactic categories (like IF) and the token strings defined in these 
 * %token declarations (like "if").  
 *
 * The Horn system uses tokens as leaf nodes and as AST node operators.  A
 * rule such as
 *     if_stmt: "if"^ expression ":"! ...
 * with no action, by default creates an AST node whose operator is an "if"
 * token (with syntactic category IF, given the %token declaration above).
 * When the node type does not correspond to a token that appears in the 
 * program, we define a dummy token type that serves only as an AST
 * node type.  For example, we can define
 *     %token DICT_DISPLAY ...
 * and then use
 *     dict_display: "{"! key_datum_list? "}"! 
 *              { $$ = $^(DICT_DISPLAY, $*); }
 * in the grammar (using DICT_DISPLAY only in actions, not as a grammar
 * symbol).
 *
 * In this skeleton, we've used a simple kludge to extract the printed forms
 * of AST operators from the operators themselves.  When a token such as IF
 * is the operator, yyexternal_token_name returns the operator name directly.
 * When there is no such correspondence, as with DICT_DISPLAY, we'll define
 *     %token DICT_DISPLAY "@dict_display"
 * Since "@dict_display" is not a valid token (it would be an error for this
 * to appear in any Python program) and does not appear in the grammar, this
 * declaration has no effect on the language recognized.  However, it
 * still provides an easy way to find the external name of an operator (just
 * strip off the leading "@").  (We can't just use "dict_display", since that
 * would tell Horn to define 'dict_display' as a token, whereas it would be a
 * simple identifier if it actually appeared in a Python program.  This is
 * where the kludginess comes in.) The AST_Tree::external_name method does
 * this conversion, converting tokens that are supposed to represent
 * node operators to printable strings.
 */

%token PRINTLN "@println"
%token EMPTY 
%token EXPR_LIST "@expr_list"
%token LITERAL "@literal"
%token MODULE "@module"
%token IF_STMT "@if_stmt"
%token ELIF_STMT "@elif_stmt"
%token ELSE_STMT "@else_stmt"
%token BOOLEAN_STMT "@boolean_stmt"
%token ITERABLE "@iterable"
%token LPAREN "@("
%token RPAREN "@)"
%token COLON "@:"
%token COMPARE "@compare"
%token ASSIGN "@="
%token DEF "@def"
%token ARGLIST "@args"
%token KEY_VALUE_PAIR "@key_value_pair"
%token DICTIONARY "@dict"
%token ASSIGNMENT "@assignment"
%token LISTACC "@listacc" 
%token FUNCCALL "@funccall" 
%token DOTNOTATION "@dot_notation"
%token CODEBLOCK "@codeblock"
%token RETURN "@return"
%token POWER "@power"
%token TEST "@test"
%token NATIVE "@native"
%token CLASS "@class"
%token PASS "@pass" 
%token RHS "@rhside" 
%token LHS "@lhside"
%token TARGET_LST "@target_list"
%token BREAK "@break" 
%token CONTINUE "@continue" 
%token LIST_FOR "@list_for" 
%token COMP_FOR "@comp_for" 

%token ADD "@add"
%token SUB "@sub"
%token DIV "@div"
%token MUL "@mul"
%token FLDIV "@fldiv"
%token MOD "@mod"

%token XOR "@xor"
%token AND "@and"
%token OR "@or"
%token NOT "@not"

%token EQUALS "@=="
%token NE "@!="
%token GT "@>"
%token LT "@<"
%token GTE "@>="
%token LTE "@<="
%token IS "@is" 
%token ISNOT "@isnot" 
%token ISIN "@isin" 
%token IN "@in"
%token NOTIN "@NOTIN"

%token FOR
%token RETURN_TYPE "@return_type"
%token TYPE "@type"
%token TYPED_ID "@typed_id"
%token TYPE_LIST "@typed_list"
%token INDENT
%token DEDENT
%token WHILE
%token FUNCTION_NAME
%token LIST
%token NUMERIC_LITERAL
%token STRING_LITERAL
%token TUPLE
%token INT_LITERAL

%%
/*---------- TERMINALS -----------*/

/* Normally, throw away whitespace other than newline. */
* : (' ' | '\t' | '\r')+ ;
IDENT  : "@71684aa3418631a412d6105e160131b9"; 
DEDENT : "@d2b3009662c463c2ab96d1a73872c6f1";
NUMBER : "-"*(('1' .. '9') ('0' .. '9')* | '0'+);
STRING : "\"" ('1' .. '9' | 'a' .. 'z' | 'A' .. 'Z')* "\""; 
ID : ('a' .. 'z' | '_' | 'A' .. 'Z')('A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '_')* ;
RAWSTRING : "r\"" ('1' .. '9' | 'a' .. 'z' | 'A' .. 'Z')* "\""; 
LINEBREAK : '\n';
COMMENT : "#" ('A' .. 'Z' | 'a' .. 'z' | '_' | ' ')* '\n' ; 
MULTILINE_COMMENT : "\"\"\"" ( 'A' .. 'Z' | 'a' .. 'z' | '_' | ' ' | '\n')* "\"\"\"" '\n'? ;
/*---------- NON-TERMINALS -----------*/
program         : input_simple+         {theTree = $^(MODULE, $*); $$ = NULL;}
                |
                ;
/* INPUTS */
input_simple    : (LINEBREAK!)+ 
                | stmt                 
                | (COMMENT!)+
                | (MULTILINE_COMMENT!)+
                ;
/* FUNCTION DEFS */
definefunc      : "def"! ID params ("::"! return_type)? ":"! (codeblock | stmt_native) {$$=$^(DEF, $*);}
                ;
return_type     : type {$$=$^(RETURN_TYPE,$*);}
                ;
params          : "("! arglist ")"! {$$=$^(ARGLIST, $*);}
                ;
arglist         : argument      
                | argument (","! argument ","!?)* 
                | /*empty*/
                ;
defineclass     : "class"! type ":"! codeblock {$$=$^(CLASS, $*);}
                ;
/* STATEMENTS */
stmt            : stmt_simple 
                | stmt_comp
                ;
stmtnoclass     : stmt_simple
                | stmtcompnoclass
                ;
stmtnodef       : stmt_simple
                | stmtcompnodef
                ;
stmt_simple     : stmt_small (";"! stmt_small)* ";"!? (LINEBREAK!)+
                ;
stmt_small      : stmt_expr 
                | stmt_print
                | stmt_pass 
                | stmt_flow 
                ;
stmt_native     : "native"! M+=STRING {$$=$^(NATIVE, $M);}
                | LINEBREAK+ IDENT "native"! M+=STRING LINEBREAK* DEDENT LINEBREAK* {$$=$^(NATIVE, $M);}
                ;
stmt_expr       : testlist 
                | lefthand ("="! testlist)+
                ;
stmt_print      : "print"! (test (","! test)* ","!? | ">>"! test (","! test)+ ","!?)? {$$=$^(PRINTLN, $*);}
                ;
stmt_pass       : "pass"!
                ;
stmt_flow       : stmt_break
                | stmt_continue
                | stmt_return
                ;
stmt_break      : "break"! {$$=$^(BREAK, $*);}
                ;
stmt_continue   : "continue"! {$$=$^(CONTINUE, $*);}
                ;
stmt_return     : "return"! testlist? {$$=$^(RETURN, $*);}
                ;
stmt_comp       : stmt_if
                | stmt_while
                | stmt_for 
                | definefunc
                | defineclass 
                ;
stmtcompnoclass : stmt_if
                | stmt_while
                | stmt_for
                | definefunc
                ;
stmtcompnodef   : stmt_if
                | stmt_while
                | stmt_for
                ;
stmt_if         : "if"! test ":"! flowblock stmt_elif* stmt_else? {$$=$^(IF_STMT, $*);}
                ;
stmt_elif       : "elif"! test ":"! flowblock {$$=$^(ELIF_STMT, $*);}
                ;
stmt_else       : "else"! ":"! flowblock {$$=$^(ELSE_STMT, $*);}
                ;
stmt_while      : "while"! test ":"! flowblock ("else"! ":"! flowblock)? {$$=$^(WHILE, $*);}
                ;
stmt_for        : "for"! exprlist "in"! testlist ":"! flowblock ("else"! ":"! flowblock)? {$$=$^(FOR, $*);}
                ;
codeblock       : stmt_simple 
                | LINEBREAK+ IDENT M+=stmtnoclass+ LINEBREAK* DEDENT (LINEBREAK!)* {$$=$^(CODEBLOCK, $M);}
                ;
flowblock       : stmt_simple
                | LINEBREAK+ IDENT M+=stmtnodef+ LINEBREAK* DEDENT LINEBREAK* {$$=$^(CODEBLOCK, $M);}
                ;
test            : or_test ("if" or_test "else" test)? 
                ;
or_test         : and_test (M+="or"! and_test)* {if(!$M.missing()){$$=$^(OR, $*);}}
                ;
and_test        : not_test (M+="and"! not_test)* {if(!$M.missing()){$$=$^(AND, $*);}}
                ;
not_test        : M+="not"! not_test {if(!$M.missing()){$$=$^(NOT, $*);}}
                | comparison
                ;
comparison      : expr ("<"! expr)+ {$$=$^(LT, $*);}
                | expr (">"! expr)+ {$$=$^(GT, $*);}
                | expr ("=="! expr)+ {$$=$^(EQUALS, $*);}
                | expr ("<="! expr)+ {$$=$^(LTE, $*);}
                | expr (">="! expr)+ {$$=$^(GTE, $*);}
                | expr ("!="! expr)+ {$$=$^(NE, $*);}
                | expr ("in"! expr)+ {$$=$^(IN, $*);}
                | expr ("not"! "in"! expr)+ {$$=$^(NOTIN, $*);}
                | expr ("is"! expr)+ {$$=$^(IS, $*);}
                | expr ("is"! "not"! expr)+ {$$=$^(ISNOT, $*);}
                | expr
                ;
expr            : expr_arith ("|"! expr_arith)*
                ;
expr_arith      : expr_add
                | expr_sub
                ;
expr_add        : term (A+="+"! term)* {if(!$A.missing()){$$=$^(ADD,$*);}}
                ;
expr_sub        : term (S+="-"! term)* {if(!$S.missing()){$$=$^(SUB,$*);}}
                ;
term            : factor (M+="*"! factor)+ {if(!$M.missing()){$$=$^(MUL,$*);}}
                | factor (D+="/"! factor)+ {if(!$D.missing()){$$=$^(DIV, $*);}}
                | factor (M+="%"! factor)+ {if(!$M.missing()){$$=$^(MOD, $*);}}
                | factor (D+="//"! factor)+ {if(!$D.missing()){$$=$^(FLDIV, $*);}}
                | factor 
                ;
factor          : ("+"! | "-"! | "~"!) atom
                | atom ("("! L+=arglist? ")"!)+ ("**"! F+=atom)? {if($F.missing()){$$=$^(FUNCCALL, $*);}else{$$=$^(POWER, $^(FUNCCALL,$L), $F);}} 
                | atom (L+="["! subscriptlist "]"!)+  ("**"! atom)?  {if($L.missing()){$$=$^(LISTACC, $*);}}
                | ID ("."! L+=ID)+ ("**"! atom)?   {if(!$L.missing()){$$=$^(DOTNOTATION, $*);}}
                | atom ("**"! atom) {$$=$^(POWER, $*);}
                | atom
                ; 
lefthand        : atom (L+="["! subscriptlist "]"!)+  ("**"! atom)?  {if($L.missing()){$$=$^(LISTACC, $*);}}
                | ID ("."! L+=ID)+ ("**"! atom)?   {if(!$L.missing()){$$=$^(DOTNOTATION, $*);}} 
                | atomnostring 
                ; 
atom            : "("! (testlist_comp)? ")"! 
                | "["! (listmaker)? "]"! {$$=$^(LIST, $*);}
                | "{"! (dictorsetmaker)? "}"! {$$=$^(DICTIONARY, $*);}
                | ID 
                | NUMBER
                | STRING
                | RAWSTRING
                | typed_id
                ;
atomnostring    : "("! (testlist_comp)? ")"! 
                | "["! (listmaker)? "]"! {$$=$^(LIST, $*);}
                | ID (","! ID)+ ","!?
                | ID 
                | typed_id
                ;
type            : ID {$$=$^(TYPE,$*);}
                | "$"! ID {$$=$^(TYPE,$*);}
                | ID "of"! "["! type_list "]"! {$$=$^(TYPE,$ID,$^(TYPE_LIST,$type_list));}
                ;
type_list       : type ","! type_list
                | type
                ;
typed_id        :  ID ("::"! type) {$$=$^(TYPED_ID,$*);}
                ;
listmaker       : test ((","! test)* ","!?)
                ;
testlist_comp   : test ((","! test)* ","!?)
                ;
subscriptlist   : subscript (","! subscript)* ","!?
                ;
subscript       : "."! "."! "."! 
                | test
                | test? ":"! test? 
                ;
exprlist        : expr (","! expr)* ","!?
                ;
testlist        : test (","! test)* ","!?
                ;
dictorsetmaker  : test ":"! test ((","! test ":"! test)* ","!?)
                | test ((","! test)* ","!?)
                ;
argument        : test  
                ;
%%

bool debugParser;

int
AST::lineNumber ()
{
    return yylocation_line (loc ());
}

void
parse (FILE* f, const string& name)
{
    if (debugParser)
        yydebug = 1;
    yypush_lexer (f, name);
    theTree = NULL;
    yyparse ();
    if (theTree != NULL) {
        theTree->print (cout, 0);
    }
}
