/* -*- mode: fundamental; c-file-style: "stroustrup"; indent-tabs-mode: nil -*- */
/*
Responsibilities:

Henry:
Types
Datastructures
Static typing

Kevin:
Function defs
class
indentation
ID

Will:
If/while/try - control
*/

/* apyc: Bison Parser */

/* Authors: YOUR NAMES HERE */

%define semantic_tree_type "AST"

%token INT
%token ID

%{
  #include <string>
  #include "apyc.h"
  #include "ast.h"
  #include <cstdio>
  #include <cstdlib>
  #include <string>

  using namespace std;

  static AST_Ptr theTree;

%}

%debug
%define error_function error

/* A token declaration such as
 *   %token INDENT
 * declares a new integer constant INDENT, which serves as a syntactic category
 * (suitable for output by the lexer) identifying a kind of token, which we
 * also often refer to as INDENT. A declaration such as
 *   %token IF "if"
 * defines a constant IF and makes it the syntactic category for the token
 * "if".  The built-in function yyexternal_token_name(...) maps between 
 * syntactic categories (like IF) and the token strings defined in these 
 * %token declarations (like "if").  
 *
 * The Horn system uses tokens as leaf nodes and as AST node operators.  A
 * rule such as
 *     if_stmt: "if"^ expression ":"! ...
 * with no action, by default creates an AST node whose operator is an "if"
 * token (with syntactic category IF, given the %token declaration above).
 * When the node type does not correspond to a token that appears in the 
 * program, we define a dummy token type that serves only as an AST
 * node type.  For example, we can define
 *     %token DICT_DISPLAY ...
 * and then use
 *     dict_display: "{"! key_datum_list? "}"! 
 *              { $$ = $^(DICT_DISPLAY, $*); }
 * in the grammar (using DICT_DISPLAY only in actions, not as a grammar
 * symbol).
 *
 * In this skeleton, we've used a simple kludge to extract the printed forms
 * of AST operators from the operators themselves.  When a token such as IF
 * is the operator, yyexternal_token_name returns the operator name directly.
 * When there is no such correspondence, as with DICT_DISPLAY, we'll define
 *     %token DICT_DISPLAY "@dict_display"
 * Since "@dict_display" is not a valid token (it would be an error for this
 * to appear in any Python program) and does not appear in the grammar, this
 * declaration has no effect on the language recognized.  However, it
 * still provides an easy way to find the external name of an operator (just
 * strip off the leading "@").  (We can't just use "dict_display", since that
 * would tell Horn to define 'dict_display' as a token, whereas it would be a
 * simple identifier if it actually appeared in a Python program.  This is
 * where the kludginess comes in.) The AST_Tree::external_name method does
 * this conversion, converting tokens that are supposed to represent
 * node operators to printable strings.
 */

%token PRINTLN "@println"
%token EMPTY 
%token EXPR_LIST "@expr_list"
%token LITERAL "@literal"
%token MODULE "@module"
%token IF_STMT "@if_stmt"
%token BOOLEAN_STMT "@boolean_stmt"
%token ITERABLE "@iterable"
%token LPAREN "@("
%token RPAREN "@)"
%token COLON "@:"
%token COMPARE "@compare"
%token ASSIGN "@="
%token DEF "@def"
%token ARGLIST "@args"
%token KEY_VALUE_PAIR "@key_value_pair"
%token DICTIONARY "@dict"

%token ADD "@add"
%token SUB "@sub"
%token DIV "@div"
%token MUL "@mul"

%token EQUALS "@=="
%token GT "@>"
%token LT "@<"
%token GTE "@>="
%token LTE "@<="

%token FOR
%token IN
%token INDENT
%token WHILE
%token DICT
%token FUNCTION_NAME
%token LIST
%token NUMERIC_LITERAL
%token STRING_LITERAL
%token TUPLE
%token INT_LITERAL

%%
/*---------- TERMINALS -----------*/

/* Normally, throw away whitespace other than newline. */
* : (' ' | '\t' | '\r')+ ;
IDENT : "indent"; 
DEDENT : "dedent";
NUMBER : "-"*('1' .. '9') ('0' .. '9')*;
STRING : "\"" ('1' .. '9' | 'a' .. 'z' | 'A' .. 'Z')* "\""; 
ID : ('a' .. 'z' | '_' | 'A' .. 'Z')('A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '_')* ;
RAWSTRING : "r\"\"";
LINEBREAK : '\n';
COMMENT : "#" ('A' .. 'Z' | 'a' .. 'z' | '_' | ' ')* '\n' ; 
MULTILINE_COMMENT : "\"\"\"" ( 'A' .. 'Z' | 'a' .. 'z' | '_' | ' ' | '\n')* "\"\"\"" '\n'? ;
/*---------- NON-TERMINALS -----------*/
program         : input_simple+
                |
                ;
/* INPUTS */
input_simple    : LINEBREAK+ 
                | stmt
                | COMMENT+
                | MULTILINE_COMMENT+
                ;
/* FUNCTION DEFS */
definefunc      : "def" ID params ("::" ID)? ":" codeblock
                ;
params          : "(" arglist ")"
                ;
arglist         : argument  
                | argument ("," argument ","?)*
                | /*empty*/
                ;
defineclass     : "class" ID ":" codeblock
                ;
/* STATEMENTS */
stmt            : stmt_simple 
                | stmt_comp
                ;
stmtnoclass     : stmt_simple
                | stmtcompnoclass
                ;
stmtnodef       : stmt_simple
                | stmtcompnodef
                ;
stmt_simple     : stmt_small (";" stmt_small)* ";"? LINEBREAK*
                ;
stmt_small      : stmt_expr
                | stmt_print
                | stmt_del
                | stmt_pass 
                | stmt_flow 
                | stmt_global
                | stmt_exec
                | stmt_assert
                ;
stmt_expr       : testlist "=" (expr_yield | testlist)*
                | ID "::" ID "=" (expr_yield | testlist)*
                | exprlist
                ;
stmt_print      : "print" (test ("," test)* ","? | ">>" test ("," test)+ ","?)
                ;
stmt_del        : "del" exprlist
                ;
stmt_pass       : "pass" 
                ;
stmt_flow       : stmt_break
                | stmt_continue
                | stmt_return
                | stmt_raise
                | stmt_yield
                ;
stmt_break      : "break"
                ;
stmt_continue   : "continue"
                ;
stmt_return     : "return" testlist?
                ;
stmt_yield      : expr_yield
                ;
stmt_raise      : "raise" (test ("," test (","test)?)?)?
                ;
stmt_global     : "global" ID ("," ID)*
                ;
stmt_exec       : "exec" expr ("in" test ("," test)?)?
                ;
stmt_assert     : "assert" test ("," test)?
                ;
stmt_comp       : stmt_if
                | stmt_while
                | stmt_for 
                | stmt_try
                | stmt_with
                | definefunc
                | defineclass 
                ;
stmtcompnoclass : stmt_if
                | stmt_while
                | stmt_for
                | stmt_try
                | stmt_with
                | definefunc
                ;
stmtcompnodef   : stmt_if
                | stmt_while
                | stmt_for
                | stmt_try
                | stmt_with
                ;
stmt_if         : "if" test ":" flowblock ("elif" test ":" flowblock)* ("else" ":" flowblock)?
                ;
stmt_while      : "while" test ":" flowblock ("else" ":" flowblock)?
                ;
stmt_for        : "for" exprlist "in" testlist ":" flowblock ("else" ":" flowblock)?
                ;
stmt_try        : "try" ":" flowblock ((except_clause ":" flowblock)+ ("else" ":" flowblock)? ("finally" ":" flowblock)? | "finally" ":" flowblock)
                ;
stmt_with       : "with" with_item ("," with_item)* ":" flowblock
                ;
with_item       : test ("as" expr)?
                ;
except_clause   : "except" (test (("as" | ",") test)?)?
                ;
codeblock       : stmt_simple 
                | LINEBREAK+ IDENT stmtnoclass+ LINEBREAK* DEDENT LINEBREAK*
                ;
flowblock       : stmt_simple
                | LINEBREAK+ IDENT stmtnodef+ LINEBREAK* DEDENT LINEBREAK*
                ;
testlist_safe   : old_test (("," old_test)+ ","?)?
                ;
old_test        : or_test 
                | old_lambdef
                ;
old_lambdef     : "lambda" arglist? ":" old_test
                ;

test            : or_test ("if" or_test "else" test)?
                | lambdef
                ;
or_test         : and_test ("or" and_test)*
                ;
and_test        : not_test ("and" not_test)*
                ;
not_test        : "not" not_test
                | comparison
                ;
comparison      : expr (comp_op expr)*
                ;
comp_op         : "<"
                | ">"
                | "=="
                | "<="
                | ">="
                | "!="
                | "in"
                | "not" "in"
                | "is" 
                | "is" "not" 
                ;
expr            : expr_xor ("|" expr_xor)*
                ;
expr_xor        : expr_and ("^" expr_and)*
                ;
expr_and        : expr_shift ("&" expr_shift)*
                ;
expr_shift      : expr_arith (("<<"|">>") expr_arith)*
                ;
expr_arith      : term (("+"|"-") term)*
                ;
term            : factor (("*"|"/"|"%"|"//") factor)*
                ;
factor          : ("+" | "-" | "~") factor
                | power
                ;
power           : atom trailer* ("**" factor)?
                ;
atom            : "(" (expr_yield | testlist_comp)? ")"
                | "[" (listmaker)? "]"
                | "{" (dictorsetmaker)? "}"
                | "`" testlist1 "`"
                | ID 
                | NUMBER+
                | STRING+
                ;
listmaker       : test (list_for | ("," test)* ","?)
                ;
testlist_comp   : test (comp_for | ("," test)* ","?)
                ;
lambdef         : "lambda" arglist? ":" test
                ;
trailer         : "(" arglist? ")"
                | "[" subscriptlist "]"
                | "." ID
                ;
subscriptlist   : subscript ("," subscript)* ","?
                ;
subscript       : "." "." "." 
                | test
                | test? ":" test? sliceop?
                ;
sliceop         : ":" test
                ;
exprlist        : expr ("," expr)* ","?
                ;
testlist        : test ("," test)* ","?
                ;
dictorsetmaker  : test ":" test (comp_for | ("," test ":" test)* ","?)
                | test (comp_for | ("," test)* ","?)
                ;
argument        : test comp_for? 
                | test "=" test
                | ID "::" ID
                ;
list_iter       : list_for 
                | list_if 
                ;
list_for        : "for" exprlist "in" testlist_safe list_iter? 
                ;
list_if         : "if" old_test list_iter? 
                ;
comp_iter       : comp_for 
                | comp_if
                ;
comp_for        : "for" exprlist "in" or_test comp_iter? 
                ;
comp_if         : "if" old_test comp_iter?
                ;
testlist1       : test ("," test)*
                ;
expr_yield      : "yield" testlist?
                ;
%%

bool debugParser;

int
AST::lineNumber ()
{
    return yylocation_line (loc ());
}

void
parse (FILE* f, const string& name)
{
    if (debugParser)
        yydebug = 1;
    yypush_lexer (f, name);
    theTree = NULL;
    yyparse ();
    if (theTree != NULL) {
        theTree->print (cout, 0);
    }
}
