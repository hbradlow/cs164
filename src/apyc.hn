/* -*- mode: fundamental; c-file-style: "stroustrup"; indent-tabs-mode: nil -*- */
/*
Responsibilities:

Henry:
Types
Datastructures
Static typing   -   Done
arithmetic

Kevin:
Function defs
class
indentation
ID

Will:
If/while/try - control

*/

/* apyc: Bison Parser */

/* Authors: YOUR NAMES HERE */

%define semantic_tree_type "AST"

%token INT
%token ID

%{
  #include <string>
  #include "apyc.h"
  #include "ast.h"
  #include <cstdio>
  #include <cstdlib>
  #include <string>

  using namespace std;

  static AST_Ptr theTree;

%}

%debug
%define error_function error

/* A token declaration such as
 *   %token INDENT
 * declares a new integer constant INDENT, which serves as a syntactic category
 * (suitable for output by the lexer) identifying a kind of token, which we
 * also often refer to as INDENT. A declaration such as
 *   %token IF "if"
 * defines a constant IF and makes it the syntactic category for the token
 * "if".  The built-in function yyexternal_token_name(...) maps between 
 * syntactic categories (like IF) and the token strings defined in these 
 * %token declarations (like "if").  
 *
 * The Horn system uses tokens as leaf nodes and as AST node operators.  A
 * rule such as
 *     if_stmt: "if"^ expression ":"! ...
 * with no action, by default creates an AST node whose operator is an "if"
 * token (with syntactic category IF, given the %token declaration above).
 * When the node type does not correspond to a token that appears in the 
 * program, we define a dummy token type that serves only as an AST
 * node type.  For example, we can define
 *     %token DICT_DISPLAY ...
 * and then use
 *     dict_display: "{"! key_datum_list? "}"! 
 *              { $$ = $^(DICT_DISPLAY, $*); }
 * in the grammar (using DICT_DISPLAY only in actions, not as a grammar
 * symbol).
 *
 * In this skeleton, we've used a simple kludge to extract the printed forms
 * of AST operators from the operators themselves.  When a token such as IF
 * is the operator, yyexternal_token_name returns the operator name directly.
 * When there is no such correspondence, as with DICT_DISPLAY, we'll define
 *     %token DICT_DISPLAY "@dict_display"
 * Since "@dict_display" is not a valid token (it would be an error for this
 * to appear in any Python program) and does not appear in the grammar, this
 * declaration has no effect on the language recognized.  However, it
 * still provides an easy way to find the external name of an operator (just
 * strip off the leading "@").  (We can't just use "dict_display", since that
 * would tell Horn to define 'dict_display' as a token, whereas it would be a
 * simple identifier if it actually appeared in a Python program.  This is
 * where the kludginess comes in.) The AST_Tree::external_name method does
 * this conversion, converting tokens that are supposed to represent
 * node operators to printable strings.
 */

%token PRINTLN "@print"
%token EMPTY 
%token EXPR_LIST "@expr_list"
%token LITERAL "@literal"
%token MODULE "@module"
%token IF_STMT "@if_stmt"
%token ELIF_STMT "@elif_stmt"
%token ELSE_STMT "@else_stmt"
%token BOOLEAN_STMT "@boolean_stmt"
%token ITERABLE "@iterable"
%token LPAREN "@("
%token RPAREN "@)"
%token COLON "@:"
%token COMPARE "@compare"
%token ASSIGN "@="
%token DEF "@def"
%token ARGLIST "@args"
%token KEY_VALUE_PAIR "@key_value_pair"
%token DICTIONARY "@dict"
%token ASSIGNMENT "@assignment"
%token LISTACC "@listacc" 
%token FUNCCALL "@funccall" 
%token DOTNOTATION "@dot_notation"
%token CODEBLOCK "@codeblock"
%token RETURN "@return"
%token POWER "@power"
%token TEST "@test"
%token NATIVE "@native"
%token CLASS "@class"
%token DEL "@del"
%token PASS "@pass" 
%token BREAK "@break" 
%token CONTINUE "@continue" 
%token RAISE "@raise" 
%token GLOBAL "@global" 
%token EXEC "@exec" 
%token ASSERT "@assert" 
%token TRY "@try" 
%token WITH "@with" 
%token EXCEPT "@except"
%token LIST_FOR "@list_for" 
%token COMP_FOR "@comp_for" 
%token YIELD "@yield"

%token ADD "@add"
%token SUB "@sub"
%token DIV "@div"
%token MUL "@mul"
%token FLDIV "@fldiv"
%token MOD "@mod"

%token XOR "@xor"
%token AND "@and"
%token OR "@or"

%token EQUALS "@=="
%token NE "@!="
%token GT "@>"
%token LT "@<"
%token GTE "@>="
%token LTE "@<="
%token IS "@is" 
%token ISNOT "@isnot" 
%token ISIN "@isin" 
%token IN "@in"
%token NOTIN "@NOTIN"

%token FOR
%token RETURN_TYPE "@return_type"
%token TYPE "@type"
%token TYPED_ID "@typed_id"
%token TYPE_LIST "@typed_list"
%token INDENT
%token DEDENT
%token WHILE
%token FUNCTION_NAME
%token LIST
%token NUMERIC_LITERAL
%token STRING_LITERAL
%token TUPLE
%token INT_LITERAL
%token WHILE_STMT "while"
%token NOT "not"

%%
/*---------- TERMINALS -----------*/

/* Normally, throw away whitespace other than newline. */
* : (' ' | '\t' | '\r')+ ;
IDENT  : "@71684aa3418631a412d6105e160131b9"; 
DEDENT : "@d2b3009662c463c2ab96d1a73872c6f1";
NUMBER : "-"*(('1' .. '9') ('0' .. '9')* | '0'+);
STRING : "\"" ('1' .. '9' | 'a' .. 'z' | 'A' .. 'Z')* "\""; 
ID : ('a' .. 'z' | '_' | 'A' .. 'Z')('A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '_')* ;
RAWSTRING : "r\"" ('1' .. '9' | 'a' .. 'z' | 'A' .. 'Z')* "\""; 
LINEBREAK : '\n';
COMMENT : "#" ('A' .. 'Z' | 'a' .. 'z' | '_' | ' ')* '\n' ; 
MULTILINE_COMMENT : "\"\"\"" ( 'A' .. 'Z' | 'a' .. 'z' | '_' | ' ' | '\n')* "\"\"\"" '\n'? ;
/*---------- NON-TERMINALS -----------*/
program         : input_simple+         {theTree = $^(MODULE, $*); $$ = NULL;}
                |
                ;
/* INPUTS */
input_simple    : (LINEBREAK!)+ 
                | stmt                 
                | (COMMENT!)+
                | (MULTILINE_COMMENT!)+
                ;
/* FUNCTION DEFS */
definefunc      : "def"! ID params ("::"! return_type)? ":"! (codeblock | stmt_native) {$$=$^(DEF, $*);}
                ;
return_type     : type {$$=$^(RETURN_TYPE,$*);}
                ;
params          : "("! arglist ")"! {$$=$^(ARGLIST, $*);}
                ;
arglist         : argument      
                | argument (","! argument ","!?)* 
                | /*empty*/
                ;
defineclass     : "class"! type ":"! codeblock {$$=$^(CLASS, $*);}
                ;
/* STATEMENTS */
stmt            : stmt_simple 
                | stmt_comp
                ;
stmtnoclass     : stmt_simple
                | stmtcompnoclass
                ;
stmtnodef       : stmt_simple
                | stmtcompnodef
                ;
stmt_simple     : stmt_small (";"! stmt_small)* ";"!? (LINEBREAK!)+
                ;
stmt_small      : stmt_expr
                | stmt_assign
                | stmt_print
                | stmt_del
                | stmt_pass 
                | stmt_flow 
                | stmt_global
                | stmt_exec
                | stmt_assert
                ;
stmt_native     : "native"! M+=STRING {$$=$^(NATIVE, $M);}
                | LINEBREAK+ IDENT "native"! M+=STRING LINEBREAK* DEDENT LINEBREAK* {$$=$^(NATIVE, $M);}
                ;
stmt_expr       : exprlist
                ;
stmt_assign     : assignment assignment* (test | expr | atom) {$$=$^(ASSIGNMENT,$*);}
                ;
assignment      : ID "="! 
                | typed_id "="! 
                ;
stmt_print      : "print"! (test (","! test)* ","!? | ">>"! test (","! test)+ ","!?) {$$=$^(PRINTLN, $*);}
                | "print"!  {$$=$^(PRINTLN, $*);}
                ;
stmt_del        : "del"! exprlist {$$=$^(DEL, $*);}
                ;
stmt_pass       : "pass"! {$$=$^(PASS, $*);} 
                ;
stmt_flow       : stmt_break
                | stmt_continue
                | stmt_return
                | stmt_raise
                | stmt_yield
                ;
stmt_break      : "break"! {$$=$^(BREAK, $*);}
                ;
stmt_continue   : "continue"! {$$=$^(CONTINUE, $*);}
                ;
stmt_return     : "return"! testlist? {$$=$^(RETURN, $*);}
                ;
stmt_yield      : expr_yield
                ;
stmt_raise      : "raise"! (test (","! test (","!test)?)?)? {$$=$^(RAISE, $*);}
                ;
stmt_global     : "global"! ID (","! ID)* {$$=$^(GLOBAL, $*);}
                ;
stmt_exec       : "exec"! expr ("in"! test (","! test)?)? {$$=$^(EXEC, $*);}
                ;
stmt_assert     : "assert"! test (","! test)? {$$=$^(ASSERT, $*);}
                ;
stmt_comp       : stmt_if
                | stmt_while
                | stmt_for 
                | stmt_try
                | stmt_with
                | definefunc
                | defineclass 
                ;
stmtcompnoclass : stmt_if
                | stmt_while
                | stmt_for
                | stmt_try
                | stmt_with
                | definefunc
                ;
stmtcompnodef   : stmt_if
                | stmt_while
                | stmt_for
                | stmt_try
                | stmt_with
                ;
stmt_if         : "if"! test ":"! flowblock stmt_elif* stmt_else? {$$=$^(IF_STMT, $*);}
                ;
stmt_elif       : "elif"! test ":"! flowblock {$$=$^(ELIF_STMT, $*);}
                ;
stmt_else       : "else"! ":"! flowblock {$$=$^(ELSE_STMT, $*);}
                ;
stmt_while      : "while"! test ":"! flowblock ("else"! ":"! flowblock)? {$$=$^(WHILE, $*);}
                ;
stmt_for        : "for"! exprlist "in"! testlist ":"! flowblock ("else"! ":"! flowblock)? {$$=$^(FOR, $*);}
                ;
stmt_try        : "try"! ":"! flowblock ((except_clause ":"! flowblock)+ ("else"! ":"! flowblock)? ("finally"! ":"! flowblock)? | "finally"! ":"! flowblock) {$$=$^(TRY, $*);}
                ;
stmt_with       : "with"! with_item (","! with_item)* ":"! flowblock {$$=$^(WITH, $*);}
                ;
with_item       : test ("as"! expr)?
                ;
except_clause   : "except"! (test (("as"! | ","!) test)?)? {$$=$^(EXCEPT, $*);}
                ;
codeblock       : stmt_simple
                | LINEBREAK+ IDENT M+=stmtnoclass+ LINEBREAK* DEDENT (LINEBREAK!)* {$$=$^(CODEBLOCK, $M);}
                ;
flowblock       : stmt_simple
                | LINEBREAK+ IDENT M+=stmtnodef+ LINEBREAK* DEDENT LINEBREAK* {$$=$^(CODEBLOCK, $M);}
                ;
testlist_safe   : old_test (("," old_test)+ ","?)?
                ;
old_test        : or_test 
                | old_lambdef
                ;
old_lambdef     : "lambda" arglist? ":" old_test
                ;

test            : or_test ("if" or_test "else" test)? /*{$$=$^($or_test, $* );}*/
                | lambdef
                ;
or_test         : and_test ("or" and_test)* /*{$$=$^(OR, $*);}*/
                ;
and_test        : not_test ("and" not_test)* /*{$$=$^(AND, $*);}*/
                ;
not_test        : "not" not_test /*{$$=$^(NOT, $not_test);}*/
                | comparison /*{$$=$^(NOT, $comparison);}*/
                ;
comparison      : e1=expr (comp_op e2=expr)* /*{$$=$^($comp_op, $e1, $e2);}*/
                ;
comp_op         : "<"
                | ">"
                | "=="
                | "<="
                | ">="
                | "!="
                | "in"
                | "not" "in"
                | "is" 
                | "is" "not" 
                ;
expr            : expr_arith ("|"! expr_arith)*
                ;
expr_arith      : term (A+="+"! term)* {if(!$A.missing()){$$=$^(ADD,$*);}}
                | term (S+="-"! term)* {if(!$S.missing()){$$=$^(SUB,$*);}}
                ;
term            : factor (M+="*"! factor)+ {if(!$M.missing()){$$=$^(MUL,$*);}}
                | factor (D+="/"! factor)+ {if(!$D.missing()){$$=$^(DIV, $*);}}
                | factor (M+="%"! factor)+ {if(!$M.missing()){$$=$^(MOD, $*);}}
                | factor (D+="//"! factor)+ {if(!$D.missing()){$$=$^(FLDIV, $*);}}
                | factor 
                ;
factor          : ("+"! | "-"! | "~"!) factor
                | atom (D+="("! arglist? ")"!)* ("**"! factor)? {if(!$D.missing()){$$=$^(FUNCCALL, $*);}}
                | atom (D+="["! subscriptlist "]"!)*  ("**"! factor)?  {if(!$D.missing()){$$=$^(LISTACC, $*);}}
                | atom (D+="."! ID)* ("**"! factor)?   {if(!$D.missing()){$$=$^(DOTNOTATION, $*);}}
                | atom ("**"! factor) {$$=$^(POWER, $*);}
                ; 
atom            : "("! (expr_yield | testlist_comp)? ")"! 
                | "["! listmaker? "]"! {$$=$^(LIST, $*);}
                | "{"! dictorsetmaker? "}"! {$$=$^(DICTIONARY, $*);}
                | "`"! testlist1 "`"!
                | ID 
                | NUMBER
                | STRING
                | RAWSTRING
                ;
type            : ID {$$=$^(TYPE,$*);}
                | "$"! ID {$$=$^(TYPE,$*);}
                | ID "of"! "["! type_list "]"! {$$=$^(TYPE,$ID,$^(TYPE_LIST,$type_list));}
                ;
type_list       : type ","! type_list
                | type
                ;
typed_id        :  ID ("::"! type) {$$=$^(TYPED_ID,$*);}
                ;
return_type     : type {$$=$^(RETURN_TYPE,$*);}
                ;
testlist_comp   : test (comp_for | ("," test)* ","?)
                ;
testlist_comp   : test (comp_for | (","! test)* ","!?)
                ;
lambdef         : "lambda"! arglist? ":"! test
                ;
subscriptlist   : subscript (","! subscript)* ","!?
                ;
subscript       : "."! "."! "."! 
                | test
                | test? ":"! test? sliceop?
                ;
sliceop         : ":"! test
                ;
exprlist        : expr (","! expr)* ","!?
                ;
testlist        : test (","! test)* ","!?
                ;
dictorsetmaker  : test ":"! test (comp_for | (","! test ":"! test)* ","!?)
                | test (comp_for | (","! test)* ","!?)
                ;
listmaker       : test ( list_for | (","! test)* ","! )
                ;
argument        : test comp_for? 
                | typed_id
                ;
list_iter       : list_for 
                | list_if 
                ;
list_for        : "for"! exprlist "in"! testlist_safe list_iter? {$$=$^(LIST_FOR, $*);}
                ;
list_if         : "if"! old_test list_iter? 
                ;
comp_iter       : comp_for 
                | comp_if
                ;
comp_for        : "for"! exprlist "in"! or_test comp_iter? {$$=$^(COMP_FOR, $*);}
                ;
comp_if         : "if"! old_test comp_iter?
                ;
testlist1       : test (","! test)*
                ;
expr_yield      : "yield"! testlist? {$$=$^(YIELD, $*);}
                ;
%%

bool debugParser;

int
AST::lineNumber ()
{
    return yylocation_line (loc ());
}

void
parse (FILE* f, const string& name)
{
    if (debugParser)
        yydebug = 1;
    yypush_lexer (f, name);
    theTree = NULL;
    yyparse ();
    if (theTree != NULL) {
        theTree->print (cout, 0);
    }
}
