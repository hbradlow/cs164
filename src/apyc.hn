/* -*- mode: fundamental; c-file-style: "stroustrup"; indent-tabs-mode: nil -*- */
/*
Responsibilities:

Henry:
Types
Datastructures
Static typing
arithmetic

Kevin:
Function defs
class
indentation
ID

Will:
If/while/- control

*/

/* apyc: Bison Parser */

/* Authors: YOUR NAMES HERE */

%define semantic_tree_type "AST"

%token ID
%token ID_R
%token TYPE_ID

%{
  #include <string>
  #include "apyc.h"
  #include "ast.h"
  #include <cstdio>
  #include <cstdlib>
  #include <string>

  using namespace std;

  static AST_Ptr theTree;

    /* Utilities */
    /** Return a new unop node corresponding to OPERANDS, which is the list of
    *  right-hand-side semantic values of a unop production (consisting of a
    *  token for the operator, followed by the AST for the operand). */
    static AST_Ptr make_unop (const List_Ptr& operands);

    /** Return a new binop node corresponding to OPERANDS, which is the list of
    *  right-hand-side semantic values of a binop production (consisting of an
    *  AST for the first operand, a token for the operator, and an AST for the
    *  second operand). */
    static AST_Ptr make_binop (const List_Ptr& operands);
    static AST_Ptr make_compare (const List_Ptr& operands);

    /** Return a new ID node, where the text of the identifier is given by
    *  TOKEN. */
    static AST_Ptr make_id (AST_Ptr& token);
//    static string raw_val(AST_Ptr token);

%}

%debug
%define error_function error

/* A token declaration such as
 *   %token INDENT
 * declares a new integer constant INDENT, which serves as a syntactic category
 * (suitable for output by the lexer) identifying a kind of token, which we
 * also often refer to as INDENT. A declaration such as
 *   %token IF "if"
 * defines a constant IF and makes it the syntactic category for the token
 * "if".  The built-in function yyexternal_token_name(...) maps between 
 * syntactic categories (like IF) and the token strings defined in these 
 * %token declarations (like "if").  
 *
 * The Horn system uses tokens as leaf nodes and as AST node operators.  A
 * rule such as
 *     if_stmt: "if"^ expression ":"! ...
 * with no action, by default creates an AST node whose operator is an "if"
 * token (with syntactic category IF, given the %token declaration above).
 * When the node type does not correspond to a token that appears in the 
 * program, we define a dummy token type that serves only as an AST
 * node type.  For example, we can define
 *     %token DICT_DISPLAY ...
 * and then use
 *     dict_display: "{"! key_datum_list? "}"! 
 *              { $$ = $^(DICT_DISPLAY, $*); }
 * in the grammar (using DICT_DISPLAY only in actions, not as a grammar
 * symbol).
 *
 * In this skeleton, we've used a simple kludge to extract the printed forms
 * of AST operators from the operators themselves.  When a token such as IF
 * is the operator, yyexternal_token_name returns the operator name directly.
 * When there is no such correspondence, as with DICT_DISPLAY, we'll define
 *     %token DICT_DISPLAY "@dict_display"
 * Since "@dict_display" is not a valid token (it would be an error for this
 * to appear in any Python program) and does not appear in the grammar, this
 * declaration has no effect on the language recognized.  However, it
 * still provides an easy way to find the external name of an operator (just
 * strip off the leading "@").  (We can't just use "dict_display", since that
 * would tell Horn to define 'dict_display' as a token, whereas it would be a
 * simple identifier if it actually appeared in a Python program.  This is
 * where the kludginess comes in.) The AST_Tree::external_name method does
 * this conversion, converting tokens that are supposed to represent
 * node operators to printable strings.
 */

%token PLUS "@+"
%token NOT "@not"
%token LT "@<"
%token GT "@>"
%token EQUALS "@=="
%token LTE "@<="
%token GTE "@>="
%token NE "@!="

%token IS "@is"
%token NIS "@isnot"
%token IN "@in"
%token NIN "@notin"

%token EMPTY
%token MODULE "@module"
%token ARGLIST "@formals_list"
%token BINOP "@binop"
%token LCOMPARE "@left_compare"
%token COMPARE "@compare"
%token UNOP "@unop"
%token IF_EXPR "@if_expr"
%token AND "@and"
%token OR "@or"
%token TUPLE "@tuple" 
%token LIST "@list_display"
%token CALL "@call" 
%token DICT "@dict_display"
%token INT "@int_literal" 
%token EXPR_LIST "@expr_list"
%token PRINT "@print" 
%token PRINTLN "@println"
%token RETURN "@return"
%token BREAK "@break" 
%token CONT "@continue"
%token IF "@if" 
%token WHILE "@while"
%token FOR "@for"
%token DEF "@def" 
%token CLASS "@class" 
%token NATIVE "@native" 
%token STMT_LIST "@stmt_list"
%token BLOCK "@block" 
%token ASSIGN "@assign" 
%token FUNC_TYPE "@function_type"
%token TYPED_ID "@typed_id"
%token TYPE "@type"
%token TYPE_LIST "@type_list"
%token TYPE_FORMALS "@type_formals_list"
%token PAIR "@pair"
%token ATTRIBUTEREF "@attributeref"
%token SUBSCRIPT "@subscription"
%token SLICING "@slicing"
%token TARGET_LIST "@target_list"
%token TYPE_VAR "@type_var"
%%
/*---------- TERMINALS -----------*/

/* Normally, throw away whitespace other than newline. */
* : (' ' | '\t' | '\r')+ ;
IDENT  : "@71684aa3418631a412d6105e160131b9"; 
DEDENT : "@d2b3009662c463c2ab96d1a73872c6f1";
NUMBER : (('1' .. '9') ('0' .. '9')* | '0'+);
STRING : "\"" ('1' .. '9' | 'a' .. 'z' | 'A' .. 'Z')* "\""; 
ID : ('a' .. 'z' | '_' | 'A' .. 'Z')('A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '_')* ;
TYPE_ID : ("::" | '$') ('a' .. 'z' | '_' | 'A' .. 'Z')('A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '_')* ;
RAWSTRING : "r\"" ('1' .. '9' | 'a' .. 'z' | 'A' .. 'Z')* "\""; 
LINEBREAK : '\n';
COMMENT : "#" ('A' .. 'Z' | 'a' .. 'z' | '_' | ' ')* '\n' ; 
MULTILINE_COMMENT : "\"\"\"" ( 'A' .. 'Z' | 'a' .. 'z' | '_' | ' ' | '\n')* "\"\"\"" '\n'? ;
/*---------- NON-TERMINALS -----------*/
program         : input_simple+         {theTree = $^(MODULE, $*); $$ = NULL;}
                |
                ;
/* INPUTS */
input_simple    : (LINEBREAK!)+ 
                | stmt                 
                | (COMMENT!)+
                | (MULTILINE_COMMENT!)+
                ;
/* FUNCTION DEFS */
definefunc      : "def"! ID formals RT+=type? ":"! (LAST+=codeblock | NATIVE+=stmt_native) {if(!$NATIVE.missing()){
                        if($RT.missing()){
                            $$=$^(DEF, $ID,$formals,$^(EMPTY),$^(BLOCK,$NATIVE));
                        }else{
                            $$=$^(DEF,$ID,$formals,$RT,$^(BLOCK,$NATIVE));
                        }
                    }else{
                        if($RT.missing()){
                            $$=$^(DEF, $ID,$formals,$^(EMPTY),$LAST);
                        }else{
                            $$=$^(DEF,$*);
                        }
                    }}
                ;
formals         : "("! (ID | ID type)? (","! (ID | ID type))* ","!? ")"! {$$=$^(ARGLIST, $*);}
                ;
arglist         : argument      
                | argument (","! argument ","!?)* 
                | /*empty*/
                ;
defineclass     : "class"! ID ("of"! TF+=type_formals_list)?":"! codeblock {if($TF.missing()){$$=$^(CLASS, $ID,$^(TYPE_FORMALS),$codeblock);}else{$$=$^(CLASS,$*);}}
                ;
/* STATEMENTS */
stmt            : stmt_simple 
                | stmt_comp
                ;
stmtnoclass     : stmt_simple
                | stmtcompnoclass
                ;
stmtnodef       : stmt_simple
                | stmtcompnodef
                ;
stmt_simple     : stmt_small (";"! stmt_small)* ";"!? (LINEBREAK!)+
                ;
stmt_small      : stmt_expr 
                | stmt_print
                | stmt_pass 
                | stmt_flow 
                ;
stmt_native     : "native"! M+=STRING {$$=$^(NATIVE, $M);}
                | LINEBREAK+ IDENT "native"! M+=STRING LINEBREAK* DEDENT LINEBREAK* {$$=$^(NATIVE, $M);}
                ;
stmt_expr       : testlist 
                | assignment
                ;
assignment      : lefthand "="! (assignment | testlist) {$$=$^(ASSIGN, $*);}
                ;
stmt_print      : "print"! (testlist? T+=","!? | ">>"! testlist ","!?)? {if($T.missing()){$$=$^(PRINTLN, $^(EMPTY), $^(EXPR_LIST, $*));}else{$$=$^(PRINT, $^(EMPTY), $^(EXPR_LIST, $*));}}
                ;
stmt_pass       : "pass"!
                ;
stmt_flow       : stmt_break
                | stmt_continue
                | stmt_return
                ;
stmt_break      : "break"! {$$=$^(BREAK, $*);}
                ;
stmt_continue   : "continue"! {$$=$^(CONT, $*);}
                ;
stmt_return     : "return"! stmt_expr* {$$=$^(RETURN, $*);}
                ;
stmt_comp       : stmt_if
                | stmt_while
                | stmt_for 
                | definefunc
                | defineclass 
                ;
stmtcompnoclass : stmt_if
                | stmt_while
                | stmt_for
                | definefunc
                ;
stmtcompnodef   : stmt_if
                | stmt_while
                | stmt_for
                ;
stmt_if         : "if"! test ":"! (flowblock | stmt_simple) T+=stmt_elif? {if($T.missing()){$$=$^(IF, $*, $^(EMPTY));}else{$$=$^(IF, $*);}}
                | A+=expr "if"! B+=test "else"! C+=expr {$$=$^(IF_EXPR, $B, $A, $C);}
                ;
stmt_elif       : "elif"! test ":"! (flowblock | stmt_simple) stmt_elif? stmt_else? {$$=$^(IF, $*);}
                ;
stmt_else       : "else"! ":"! (flowblock | stmt_simple)
                ;
stmt_while      : "while"! test ":"! (flowblock | stmt_simple) T+=stmt_else? {if($T.missing()){$$=$^(WHILE, $*, $^(EMPTY));}else{$$=$^(WHILE, $*);}}
                ;
stmt_for        : "for"! exprlist "in"! testlist ":"! (flowblock | stmt_simple) T+=stmt_else? {if($T.missing()){$$=$^(FOR, $*, $^(EMPTY));}else{$$=$^(FOR, $*);}}
                ;
codeblock       : stmt_simple {$$=$^(BLOCK, $*);}
                | LINEBREAK+ IDENT M+=stmtnoclass+ LINEBREAK* DEDENT (LINEBREAK!)* {$$=$^(BLOCK, $M);}
                ;
flowblock       : LINEBREAK!+ IDENT! M+=stmtnodef+ LINEBREAK!* DEDENT! LINEBREAK!* {$$=$^(STMT_LIST, $*);}
                ;
test            : A+=or_test ("if"! B+=or_test "else"! C+=test)? {if(!$B.missing()){$$=$^(IF_EXPR, $B, $A, $C);}}
                ;
or_test         : and_test (M+="or"! and_test)* {if(!$M.missing()){$$=$^(OR, $*);}}
                ;
and_test        : not_test (M+="and"! not_test)* {if(!$M.missing()){$$=$^(AND, $*);}}
                ;
not_test        : M+="not" not_test {if(!$M.missing()){$$=make_unop($*);}}
                | comparison
                ;
comparison      : E1+=expr ("<" E2+=expr)+ {$$=make_compare($*);}
                | E1+=expr (">" E2+=expr)+ {$$=make_compare($*);}
                | E1+=expr ("==" E2+=expr)+ {$$=make_compare($*);}
                | E1+=expr ("<=" E2+=expr)+ {$$=make_compare($*);}
                | E1+=expr (">=" E2+=expr)+ {$$=make_compare($*);}
                | E1+=expr ("!=" E2+=expr)+ {$$=make_compare($*);}

                | E1+=expr ("in" E2+=expr)+ {$$=make_binop($*);}
                | E1+=expr ("not in" E2+=expr)+ {$$=make_binop($*);}
                | E1+=expr ("is" E2+=expr)+ {$$=make_binop($*);}
                | E1+=expr ("is not" E2+=expr)+ {$$=make_binop($*);}
                | expr
                ;
expr            : expr_arith 
                ;
expr_arith      : term (A+="-" term)+ {if(!$A.missing()){$$=make_binop($*);}}
                | term (A+="+" term)+ {if(!$A.missing()){$$=make_binop($*);}}
                | term
                ;
term            : factor (O+="*" factor)+ {if(!$O.missing()){$$=make_binop($*);}}
                | factor (O+="/" factor)+ {if(!$O.missing()){$$=make_binop($*);}}
                | factor (O+="%" factor)+ {if(!$O.missing()){$$=make_binop($*);}}
                | factor (O+="//" factor)+ {if(!$O.missing()){$$=make_binop($*);}}
                | factor 
                ;
factor          : ('+' | '-' | '~') factor {$$=make_unop($*);}
                | atom (L+="["! subscriptlist "]"!)+ {$$=$^(SUBSCRIPT, $*);}
                | ID ("."! L+=ID)+ {$$=$^(ATTRIBUTEREF, $*);}
                | atom ("**" atom) {$$=make_binop($*);}
                | atom
                ; 
lefthand        : atom (L+="["! subscriptlist "]"!)+ {$$=$^(SUBSCRIPT, $*);}
                | ID ("."! L+=ID)+ {$$=$^(ATTRIBUTEREF, $*);} 
                | "("! (testlist_comp)? ")"! {$$=$^(TARGET_LIST, $*);}
                | "["! (listmaker)? "]"! {$$=$^(TARGET_LIST, $*);}
                | ID (","! ID)+ ","!?  {$$=$^(TARGET_LIST, $*);}
                | ID TYPE_ID {$$=$^(TYPED_ID, $*);} 
                | atomnostring
                ; 
atom            : "("! (testlist_comp)? ")"! {$$=$^(TUPLE, $*);}
                | "["! (listmaker)? "]"! {$$=$^(LIST, $*);}
                | "{"! (dictorsetmaker)? "}"! {$$=$^(DICT, $*);}
                | "("! expr ")"!
                | ID 
                | NUMBER
                | STRING
                | RAWSTRING
                | TYPE_ID 
                | atom ("("! L+=arglist? ")"!)+ {$$=$^(CALL, $atom,$^(EXPR_LIST,$L.list_value()));} 
                ;
atomnostring    : ID 
                | TYPE_ID 
                ;
type            : TYPE_ID 
                | "$"! ID {$$=$^(TYPE_VAR,$*);}
                | TYPE_ID "of"! "["! type_list "]"! {$$=$^(TYPE,$TYPE_ID,$^(TYPE_LIST,$type_list));}
                ;
type_formals_list: "["! type_list "]"! {$$=$^(TYPE_FORMALS,$*);}
                | type_list {$$=$^(TYPE_FORMALS,$*);}
                ;
type_list       : type ","! type_list
                | type
                ;
listmaker       : test ((","! test)* ","!?)
                ;
testlist_comp   : test ","! (test ","! | test?)*
                ;
subscriptlist   : subscript (","! subscript)* ","!?
                ;
subscript       : "."! "."! "."! 
                | test
                | test? ":"! test? 
                ;
exprlist        : expr (","! expr)* ","!?
                ;
testlist        : test (","! test)* ","!?
                ;
dictorsetmaker  : kvpairlist ","!?
                ;
kvpairlist      : kvpair (","! kvpair)* 
                ;
kvpair          : test ":"! test {$$=$^(PAIR, $*);}
                ;
argument        : test  
                ;
%%

bool debugParser;

static AST_Ptr
make_unop (const List_Ptr& operands)
{
    return YYMAKE_TREE (UNOP, make_id (operands->at (0)), operands->at (1));
}

static AST_Ptr
make_compare (const List_Ptr& operands)
{
    return YYMAKE_TREE (COMPARE, operands->at (0), make_id (operands->at (1)),
    operands->at (2));
}

static AST_Ptr
make_binop (const List_Ptr& operands)
{
    return YYMAKE_TREE (BINOP, operands->at (0), make_id (operands->at (1)),
    operands->at (2));
}

/*
static string
raw_val(AST_Ptr token){
    return string(token.as_chars());
}
*/
static AST_Ptr
make_id (AST_Ptr& token)
{
    AST_Ptr result = AST::make_token (ID, token->text_size (),
        token->as_chars (), false);
    result->set_loc (token->loc ());
    return result;
}

int
AST::lineNumber ()
{
    return yylocation_line (loc ());
}

void
parse (FILE* f, const string& name)
{
    if (debugParser)
        yydebug = 1;
    yypush_lexer (f, name);
    theTree = NULL;
    yyparse ();
    if (theTree != NULL) {
        theTree->print (cout, 0);
    }
}
