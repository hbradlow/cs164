/* -*- mode: fundamental; c-file-style: "stroustrup"; indent-tabs-mode: nil -*- */
/*
Responsibilities:

Henry:
Types
Datastructures
Static typing

Kevin:
Function defs
class
indentation
ID

Will:
If/while/try - control
*/

/* apyc: Bison Parser */

/* Authors: YOUR NAMES HERE */

%define semantic_tree_type "AST"

%token INT
%token ID

%{
  #include <string>
  #include "apyc.h"
  #include "ast.h"
  #include <cstdio>
  #include <cstdlib>
  #include <string>

  using namespace std;

  static AST_Ptr theTree;

%}

%debug
%define error_function error

/* A token declaration such as
 *   %token INDENT
 * declares a new integer constant INDENT, which serves as a syntactic category
 * (suitable for output by the lexer) identifying a kind of token, which we
 * also often refer to as INDENT. A declaration such as
 *   %token IF "if"
 * defines a constant IF and makes it the syntactic category for the token
 * "if".  The built-in function yyexternal_token_name(...) maps between 
 * syntactic categories (like IF) and the token strings defined in these 
 * %token declarations (like "if").  
 *
 * The Horn system uses tokens as leaf nodes and as AST node operators.  A
 * rule such as
 *     if_stmt: "if"^ expression ":"! ...
 * with no action, by default creates an AST node whose operator is an "if"
 * token (with syntactic category IF, given the %token declaration above).
 * When the node type does not correspond to a token that appears in the 
 * program, we define a dummy token type that serves only as an AST
 * node type.  For example, we can define
 *     %token DICT_DISPLAY ...
 * and then use
 *     dict_display: "{"! key_datum_list? "}"! 
 *              { $$ = $^(DICT_DISPLAY, $*); }
 * in the grammar (using DICT_DISPLAY only in actions, not as a grammar
 * symbol).
 *
 * In this skeleton, we've used a simple kludge to extract the printed forms
 * of AST operators from the operators themselves.  When a token such as IF
 * is the operator, yyexternal_token_name returns the operator name directly.
 * When there is no such correspondence, as with DICT_DISPLAY, we'll define
 *     %token DICT_DISPLAY "@dict_display"
 * Since "@dict_display" is not a valid token (it would be an error for this
 * to appear in any Python program) and does not appear in the grammar, this
 * declaration has no effect on the language recognized.  However, it
 * still provides an easy way to find the external name of an operator (just
 * strip off the leading "@").  (We can't just use "dict_display", since that
 * would tell Horn to define 'dict_display' as a token, whereas it would be a
 * simple identifier if it actually appeared in a Python program.  This is
 * where the kludginess comes in.) The AST_Tree::external_name method does
 * this conversion, converting tokens that are supposed to represent
 * node operators to printable strings.
 */

%token PRINTLN "@println"
%token EMPTY 
%token EXPR_LIST "@expr_list"
%token LITERAL "@literal"
%token MODULE "@module"
%token IF_STMT "@if_stmt"
%token BOOLEAN_STMT "@boolean_stmt"
%token ITERABLE "@iterable"
%token LPAREN "@("
%token RPAREN "@)"
%token COLON "@:"
%token COMPARE "@compare"
%token ASSIGN "@="

%token KEY_VALUE_PAIR "@key_value_pair"
%token DICTIONARY "@dict"

%token ADD "@add"
%token SUB "@sub"
%token DIV "@div"
%token MUL "@mul"

%token EQUALS "@=="
%token GT "@>"
%token LT "@<"
%token GTE "@>="
%token LTE "@<="

%token COMMA ","
%token DEDENT 
%token DEF
%token FOR
%token IN
%token INDENT
%token WHILE
%token DICT
%token FUNCTION_NAME
%token LIST
%token NUMERIC_LITERAL
%token STRING_LITERAL
%token TUPLE
%token INT_LITERAL

%%
/*---------- TERMINALS -----------*/

/* Normally, throw away whitespace other than newline. */
* : (' ' | '\t' | '\r')+ ;

INT_LITERAL : ('1' .. '9') ('0' .. '9')*;
STRING_LITERAL : "\"" ('1' .. '9')* "\""; 
ID : ('a' .. 'z')('a' .. 'z')* ;
RAWSTRING : "r\"\"";

/*---------- NON-TERMINALS -----------*/

program         : stmt_list   { theTree = $^(MODULE, $*); $$ = NULL; }
                ;
stmt_list       : stmt stmt_list 
                | /*empty*/
                ;
stmt            : if_stmt 
                | while_stmt 
                | def_stmt 
                | for_stmt 
                | expression 
                | assignment
                | print_stmt
                ;

assignment      : ID "="! expression "\n"! {$$ = $^(ASSIGN,$*);}
                ;
arithmetic      : expression "+"! expression {$$=$^(ADD,$*);}
                | expression "-"! expression {$$=$^(SUB,$*);}
                | expression "/"! expression {$$=$^(DIV,$*);}
                | expression "*"! expression {$$=$^(MUL,$*);}
                ;

dict            : "{"! key_value_list "}"! {$$=$^(DICTIONARY,$*);}
                ;
key_value_pair  : hashable ":"! expression {$$=$^(KEY_VALUE_PAIR,$*);}
                ;
key_value_list  : key_value_list ","! key_value_pair {$$=$^(KEY_VALUE_PAIR,$*);}
                | key_value_pair {$$=$^(KEY_VALUE_PAIR,$*);}
                ;
hashable        : STRING_LITERAL 
                ;
                
if_stmt         : "if" bool_stmt ":"! INDENT stmt_list DEDENT elif_stmt
                ;
elif_stmt       : "elif" bool_stmt ":"! INDENT stmt_list DEDENT elif_stmt 
                | "else" bool_stmt ":"! INDENT stmt_list DEDENT
                | /*empty*/
                ;
bool_stmt       : expression COMPARE bool_stmt 
                | "(" bool_stmt ")" 
                | expression
                ;
while_stmt      : WHILE bool_stmt COLON! INDENT stmt_list DEDENT
                ;
for_stmt        : FOR ID IN ITERABLE COLON! INDENT stmt_list DEDENT
                ;
def_stmt        : DEF FUNCTION_NAME LPAREN! parameter_list RPAREN! COLON! INDENT stmt_list DEDENT
                ;
parameter_list  : parameter COMMA! parameter_list | parameter
                ;
parameter       : ID 
                | ID ASSIGN expression
                ;
compare         : EQUALS 
                | LTE 
                | GTE 
                | LT 
                | GT
                ;
expr_list       : /*empty*/ 
                ;
file            : /*empty*/
                ;
list            : /*empty*/
                ;
literal         : INT_LITERAL {$$=$INT_LITERAL;} 
                | STRING_LITERAL {$$ = $STRING_LITERAL;}
                ;
tuple           : /*empty*/   
                ;
iterable        : expr_list 
	            ;
expression      : literal {$$=$literal;}
                | ID
                | FUNCTION_NAME expression_list 
                | arithmetic
                | dict
                ;
function        : /*empty*/
                ;	
expression_list : expression (","! expression)* { $$ = $^(EXPR_LIST, $*); }
                | /*empty*/ { $$ = $^(EXPR_LIST); }
                ;
string          : STRING_LITERAL
                ;
iterable        : list 
                | string 
                | tuple
                | dict 
                | file
                ;
print_stmt      : "print"  expression_list "\n" { $$ = $^(PRINTLN, $^(EMPTY), $expression_list); }
                ;

%%

bool debugParser;

int
AST::lineNumber ()
{
    return yylocation_line (loc ());
}

void
parse (FILE* f, const string& name)
{
    if (debugParser)
        yydebug = 1;
    yypush_lexer (f, name);
    theTree = NULL;
    yyparse ();
    if (theTree != NULL) {
        theTree->print (cout, 0);
    }
}
