#!/usr/bin/env python

# Test compiler against suite of Python programs.  Requires that pyunparse be
# on the path.

import os, sys, re
from subprocess import Popen, PIPE
from getopt import getopt, GetoptError

def Usage():
    print '''
Usage: test-proj1 [ --errors ] [ --compiler=COMPILER ] [ --retain ] DIR/BASE.py ...
    Runs COMPILER (default ./apyc) on each DIR/BASE.py with the command
        COMPILER --stage=1 -o BASE.ast PROGRAM-FILE
    In the absence of the --errors option, unparses the result into
    a Python program BASE-2.py, and then runs python on that program.
    If there is a file DIR/BASE.in, uses that as the standard input.
    Otherwise, uses the empty file for the standard input.  Compares
    the output to file DIR/BASE.std, if that is present, and otherwise
    just checks that the python interpreter exits normally.  Retains ASTs
    if --retain.

    With the --errors option, checks that the compiler exits with a
    non-zero exit code and that stderr contains at least one error message
    in the correct format.  Does not unparse the resulting AST or execute
    the Python interpreter.

    Reports results and exits with 0 if there are no errors, and
    with 1 otherwise.'''

def Run(command, *args, **keys):
    if args:
        command = command % args
    proc = Popen (command, shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    out, err = proc.communicate(keys.get ('stdin', ''))
    return proc.returncode, out, err

def Remove(file):
    try:
        os.unlink(file)
    except OSError:
        pass

def Contents(file):
    try:
        f = open(file)
        r = f.read()
        f.close()
        return r
    except:
        return ""

def Compile(prog, ast):
    global Stdout, Stderr
    code, Stdout, Stderr = Run("%s --phase=1 -o %s %s", compiler, ast, prog)
    return code == 0

def Unparse(ast, python):
    code, out, err = Run("../software/pyunparse -o %s --remove-extensions %s", python, ast)
    return code == 0

def Execute(prog, inp):
    global Stdout, Stderr
    code, Stdout, Stderr = Run("python %s", prog, stdin=inp)
    return code == 0

def HasError(errout):
    return re.search (r'(?m)^[^:]+\.py:\d+:\s*\S', errout)

class bcolors:
    PURPLE = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    BOLD = '\033[1m'
    ENDC = '\033[0m'

try:
    opts, tests = getopt (sys.argv[1:], 'h',
                          ['help', 'retain', 'errors', 'compiler='])
except GetoptError:
    Usage()
    sys.exit(1)

compiler = './apyc'
errors = False
retain = False

for opt, val in opts:
    if opt in ( '-h', '--help' ):
        Usage()
        sys.exit(0)
    elif opt == '--errors':
        errors = True
    elif opt == '--compiler':
        compiler = val
    elif opt == '--retain':
        retain = True

N = 0
OK = 0

for f in tests:
    dir, file = os.path.split(f)
    base, ext = os.path.splitext(file)
    if base == "*":
        # this means there is no files in that folder
        continue

    N += 1
    ast = dir + '/' + base + ".ast"
    isTestOK = False
    if errors:
        if Compile(f, ast):
            msg = bcolors.FAIL + "FAIL (wrong exit code)" + bcolors.ENDC
        elif HasError (Stderr):
            msg = bcolors.OKGREEN + "OK" + bcolors.ENDC
            OK += 1
            isTestOK = True
        else:
            msg = bcolors.FAIL + "FAIL (bad error message)" + bcolors.ENDC
    else:
        prog2 = base + "-2.py"
        inp = os.path.join(dir, base + ".in")
        std = Contents (os.path.join(dir, base + ".std"))
        skipExecution = base.startswith("_")

        if not std and not skipExecution:
            Execute(f, Contents(inp))
            std = Stdout

        if not Compile(f, ast):
            msg = bcolors.FAIL + "FAIL (wrong exit code)" + bcolors.ENDC
        elif Stderr:
            msg = bcolors.FAIL + "FAIL (error messages)" + bcolors.ENDC
        elif not Unparse(ast, prog2):
            msg = bcolors.FAIL + "FAIL (bad AST)" + bcolors.ENDC
        elif skipExecution:
            msg = bcolors.WARNING + "SKIPPED (name starts with _) " \
                    + bcolors.OKGREEN + "(good AST)" + bcolors.ENDC
            isTestOK = True
            OK += 1
        elif not Execute(prog2, Contents(inp)):
            msg = bcolors.FAIL + "FAIL (execution error)" + bcolors.ENDC
        elif Stderr:
            msg = bcolors.FAIL + "FAIL (error output on execution)" + bcolors.ENDC
        elif std and std != Stdout:
            msg = bcolors.FAIL + "FAIL (wrong output)" + bcolors.ENDC
            msg += "\n============= expected ============="
            msg += std
            msg += "=============== got ================"
            msg += Stdout
            msg += "============= end diff ============="
        else:
            msg = bcolors.OKGREEN + "OK" + bcolors.ENDC
            OK += 1
            isTestOK = True

        Remove(prog2)

    if not retain:
        Remove(ast)

    if isTestOK:
        print dir + '/' + bcolors.OKBLUE + base + bcolors.ENDC + ".py:",
    else:
        print dir + '/' + bcolors.PURPLE + base + bcolors.ENDC + ".py:",
    print msg

print
print "Ran %d tests." % N,
if OK == N:
    print bcolors.OKGREEN + "All passed." + bcolors.ENDC
    sys.exit(0)
else:
    print bcolors.WARNING + "%d failed." % (N - OK) + bcolors.ENDC
    sys.exit(1)

